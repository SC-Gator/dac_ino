/* Created: Rich Holmes, 2020 Purpose: Control DAC, analog inputs, digital outputs Much of this borrowed from Chip Audette's ribbon controller code. */#include <NewPing.h>#include <SPI.h>//debugging info#define USE_ARDUINO  1//#define USE_TEENSY  1//#define Serial_t (Serial1)  //for MIDI for Arduino Micro or for TEENSY#define Serial_t (Serial) //for MIDI for Arduino UNO or Pro Mini// define the various pins used on the Arduino/Teensy hardwareconst int d_in_a_pin = 2;const int d_in_b_pin = 3;const int d_in_c_pin = 4;const int d_in_d_pin = 5;const int d_out_a_pin = 6;const int d_out_b_pin = 7;const int a_in_a_pin = A0;const int a_in_b_pin = A1;const int a_in_c_pin = A2;const int a_in_d_pin = A3;const int a_in_e_pin = A4;const int a_in_f_pin = A5;const int slaveSelectPin = 10;  //for commanding the DAC//samplingvolatile boolean flag_update_system = true;volatile boolean flag_cannot_keep_up = false;#define SAMPLE_RATE_HZ (600.0)// Distance sensor setup// d_in_a_pin is gate in// d_out_a_pin is gate out//Define HC-SR04 parameters#define MAX_DISTANCE 350 // Maximum distance we want to ping for (in centimeters). Maximum sensor distance is rated at 400-500cm.const int trigPin = d_out_b_pin;const int echoPin = d_in_b_pin;//setup SC-SR04 pins and max distanceNewPing sonar(trigPin, echoPin, MAX_DISTANCE); // NewPing setup of pins and maximum distance.// Define window pot parametersfloat R_pullup_A3_kOhm = 0.0;float R_min_min_kOhm = 0.0;float R_range_min_kOhm = 0.0;const float R_min_max_kOhm = 17.45;const float R_range_max_kOhm = 17.45;// DAC parameters#define MAX_DAC_COUNTS (4095)#define VOLT_PER_OCTAVE (1.0)#define MAX_DAC_VOLT (4.97)   //laptop is 5.04V, USB wall-wart is 5.182Vconst float DAC_counts_per_volt = MAX_DAC_COUNTS/MAX_DAC_VOLT;#ifdef USE_TEENSYIntervalTimer sampleTimer; #endif//Define some CV parameters#define CV_note_bottom (0)  // no offsetvolatile boolean startme = false;//interrupt service routine...format of function call changes depending upon platform#ifdef USE_TEENSYvoid serviceTimer(void)     //Teensy convention#else  ISR(TIMER1_COMPA_vect)  //arduino convention#endif{//  if (startme)//  {//    if (flag_update_system)//      {//        flag_cannot_keep_up = true;//      }      //read_HCSR04();//  }}//setup routinevoid setup() {  // initialize the serial communications:  //  Serial.begin(115200*2);  //for Arduino Micro only  Serial.begin(9600);  // for Arduino Uno / Pro Mini  delay(500);  Serial.println("setup");  //setup the HC-SR04 pins and the analogRead reference  //analogReference(INTERNAL);  //analogReference(EXTERNAL);  pinMode(a_in_a_pin, INPUT_PULLUP);  pinMode(a_in_b_pin, INPUT_PULLUP);    //initialize the DAC  pinMode(slaveSelectPin, OUTPUT);  digitalWrite(slaveSelectPin,HIGH);  //set DAC ready to accept commands  SPI.begin();   SPI.setDataMode(SPI_MODE0); //MCP4922 can be either Mode 0 or Mode 3 (supposedly)  SPI.setBitOrder(MSBFIRST);    // setup window pots  //  R_pullup_A3_kOhm = R_ribbon_max_kOhm * ( ((float)HCSR04_SPAN) / ((float)HCSR04_max_val) - 1.0 );  //  R_min_min_kOhm = ((float)HCSR04_min_val) / ((float)HCSR04_max_val) * R_HCSR04_max_kOhm;  //  R_max_min_kOhm = ((float)HCSR04_min_val) / ((float)HCSR04_max_val) * R_HCSR04_max_kOhm;    //setup the timer  float dt_sec_sample = 1.0 / SAMPLE_RATE_HZ;//arduino can run up to 1200Hz as of Mar 5, 2016  #ifdef USE_TEENSY  int timer_loop_usec = (int)(dt_sec_sample*1000000.0); //microseconds  sampleTimer.begin(serviceTimer, timer_loop_usec);#else  int timer_clock_divider = 64;  //see which divider I'm using in setupTimer()  int timer_value = (int)( (16000000L) / ((long)timer_clock_divider) / ((long)SAMPLE_RATE_HZ) );  setupTimer(timer_value);#endif  startme = true;  Serial.println("setup done");}void loop(){//  Serial.println("loop");  static int idle_counter = 0;    if (flag_update_system)    {      flag_update_system = false;      updateTheSystem();    }  else    {      idle_counter++;  //kill time without being stuck in an empty loop    }}float HCSR04_duration = 0;float HCSR04_distance = 0;float CV_volts_offset = 0;float CV_volts_per_cm = (5.0 - CV_volts_offset) / MAX_DISTANCE;float CV_volts = 0;bool gate;void updateTheSystem() {    // read input  read_HCSR04(); //this is now done in the interrupt service routine!  gate = digitalRead (d_in_b_pin);    // process input  process_HCSR04();    // send CV to the DAC  updateCV (CV_volts);  // send gate to digital out  digitalWrite (d_out_b_pin, gate);}void read_HCSR04(void) {  Serial.println("read_HCSR04");    //read the HCSR04 value  if (true){  HCSR04_duration = sonar.ping();  }  HCSR04_distance = (HCSR04_duration/2) * 0.0343;    // maybe do some processing here    //print some debugging info  if (true) {    if (flag_cannot_keep_up) {      Serial.print(-HCSR04_distance); //enable this to get value at top and bottom of HCSR04 to calibrate    } else {      Serial.print(HCSR04_distance); //enable this to get value at top and bottom of HCSR04 to calibrate    }    Serial.print(" cm, duration ");    Serial.print((int)HCSR04_duration); //enable this to get value at top and bottom of HCSR04 to calibrate    Serial.println();    flag_cannot_keep_up = false;  }  flag_update_system = true;}void process_HCSR04(void) {    // For now we're ignoring the distance window pots    CV_volts = CV_volts_offset + CV_volts_per_cm * HCSR04_distance;    if (true)    {      Serial.print("CV_volts = ");      Serial.println(CV_volts);    }}#ifdef USE_ARDUINO////Code from: http://letsmakerobots.com/node/28278void setupTimer(const int &match_value_counts) {  noInterrupts();           // disable all interrupts  //we're going to use timer1  TCCR1A = 0;  //enable normal operation (mode 0)  TCCR1B = 0;  TCNT1  = 0; //reset the counter    // compare match register  //  OCR1A = 0x7a12;           // compare match register...16MHz/prescaler/sample_rate_hz  OCR1A = match_value_counts;  TCCR1B |= (1 << WGM12);   // CTC mode  //TCCR1B |= (1 << CS10);    // prescaler  (CS10=1)  //TCCR1B |= (1 << CS11);    // prescaler  (CS11=8)  TCCR1B |= ((1 << CS11) | (1 << CS10));  //CS11+CS10 = 64  //TCCR1B |= ((1 << CS12) | (1 << CS10));  //CS12+CS10 = 1024  TIMSK1 |= (1 << OCIE1A);  // enable timer compare interrupt  interrupts();             // enable all interrupts}#endif void updateCV(const float &cv_volts){  int cv_counts = (int)(cv_volts * DAC_counts_per_volt);  cv_counts = constrain (cv_counts, 0, MAX_DAC_COUNTS);  MCP4922_write (slaveSelectPin, cv_counts);}void MCP4922_write(const int &slavePin,const int &value) {  byte configByte = 0;  byte data=0;  int channel=0;    Serial.print ("MCP4922_write ");  Serial.println (value);  digitalWrite(slavePin,LOW);  //set DAC ready to accept commands  configByte = B01110000; //channel 0, Vref buffered, Gain of 1x, Active Mode    //write first byte  data = highByte(value);  data = B00001111 & data;  //clear out the 4 command bits  data = configByte | data;  //set the first four command bits  SPI.transfer(data);    //write second byte  data = lowByte(value);  SPI.transfer(data);    //close the transfer  digitalWrite(slavePin,HIGH);  //set DAC ready to accept commands  Serial.println ("done");  }